import com.google.protobuf.{ByteString, ExtensionRegistry, UnknownFieldSet}
import com.google.protobuf.compiler.PluginProtos.CodeGeneratorRequest
import protocbridge.{Artifact, JvmGenerator, ProtocCodeGenerator}
import protocgen.CodeGenRequest
import scalapb.compiler.ProtobufGenerator
import scalapb.options.Scalapb
import sbt.{File, IO, Logger}

import java.time.LocalDateTime
import java.{lang, util}
import scala.collection.JavaConverters._
import scala.util.{Failure, Success, Try}

class AlonaScalaPbCodeGenerator(logger: Logger, registryPath: File) extends ProtocCodeGenerator {
  override def run(request: Array[Byte]): Array[Byte] = {
    logger.info("Start generating ...")
    val registry = ExtensionRegistry.newInstance()
//    Scalapb.registerAllExtensions(registry)
    Scalapb.registerAllExtensions(registry)
    val codeGeneratorRequest = CodeGeneratorRequest.parseFrom(request, registry)
    val messagesList = codeGeneratorRequest.getProtoFileList.asScala.toList
    var valid = true

    val protoMessages = messagesList.flatMap(file => {
      file.getMessageTypeList.asScala.flatMap(message => {
//        logger.info("message: " + message)
        Try {
//          message.getOptions.getUnknownFields.asMap().asScala(60000).getVarintList.asScala.head
          val byteString = message.getOptions.getUnknownFields.asMap().asScala(50000)
            .getLengthDelimitedList.asScala.head
          UnknownFieldSet.parseFrom(byteString).asMap().asScala(1)
            .getVarintList.asScala.head
        } match {
          case Failure(_) => {
            logger.error(s"Unable to find type_id for message [${message.getName}] in file ${file.getName}")
            valid = false
            Nil
          }
          case Success(manifest) => {
            if (manifest < 1L) {
              logger.error(s"Invalid type_id (less than 1) for message [${message.getName} in file ${file.getName}]")
              valid = false
              Nil
            } else {
              List((message, file, manifest))
            }
          }
        }
      })
    }).sortBy(_._3)
    logger.info("protoMessages: " + protoMessages.length)
    // TODO: Test toMessageCreationFunction if typeId doesn't exist, if it will be handled by the Try
    val dateNow = LocalDateTime.now()
    val registrySource =
      s"""package com.eycads.sdk.protocols
         |
         |import scalapb.GeneratedMessage
         |
         |import scala.util.Try
         |
         |/**
         | * Copyright (c) ${dateNow.getYear.toString}
         | * Template: ScalaPbManifest
         | * File: ScalaPbManifest.java
         | *
         | * Version	    Date
         | * -----------------------------------------------------
         | * v0.1			    ${dateNow.toString}
         | * Generated by SBT Alona Project
         | */
         |object ScalaPbManifest {
         |
         |  def toMessageCreationFunction(typeId: Int): Array[Byte] => Try[GeneratedMessage] =
         |    typeId match {
         |      ${protoMessages.map(msg => s"case ${msg._3} => ${msg._2.getPackage}.${msg._1.getName}.validate").mkString("\n      ")}
         |      case x => throw new java.util.NoSuchElementException(s"manifest $$x not found")
         |    }
         |
         |  def getNamePartialFunction: PartialFunction[Int, String] =
         |    {
         |      ${protoMessages.map(msg => s"""case ${msg._3} => "${msg._2.getPackage}.${msg._1.getName}"""").mkString("\n      ")}
         |    }
         |
         |  def getOptionName(typeId: Int): Option[String] =
         |    getNamePartialFunction.lift(typeId)
         |
         |  def getName(typeId: Int): String =
         |    try {
         |      getNamePartialFunction(typeId)
         |    } catch {
         |       case _: Throwable => throw new java.util.NoSuchElementException(s"manifest $$typeId not found")
         |    }
         |}
         """.stripMargin
    IO.write(registryPath, registrySource)
//    ProtobufGenerator.handleCodeGeneratorRequest(codeGeneratorRequest).toByteArray
    ProtobufGenerator.handleCodeGeneratorRequest(CodeGenRequest(codeGeneratorRequest)).toCodeGeneratorResponse.toByteArray
  }

  override def suggestedDependencies: Seq[Artifact] = Seq(
    Artifact("com.thesamet.scalapb", "scalapb-runtime", scalapb.compiler.Version.scalapbVersion, crossVersion = true)
  )

}

object AlonaScalaPbCodeGenerator {
  def apply(logger: Logger, registryPath: File): (JvmGenerator, Seq[String]) = {
    val alonaScalaPbCodeGenerator: AlonaScalaPbCodeGenerator =
      new AlonaScalaPbCodeGenerator(logger, registryPath)
    val options: Seq[String] = Seq(
      "flat_package" -> false,
      "java_conversions" -> false,
      "grpc" -> true,
      "single_line_to_string" -> false
    ).collect { case (name, v) if v => name }
    (JvmGenerator("scala-alona", alonaScalaPbCodeGenerator), options)
  }
}
